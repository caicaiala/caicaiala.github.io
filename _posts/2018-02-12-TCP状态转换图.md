---
layout:     post
title:      TCP状态转换图
subtitle:   CLOSE_WAIT状态错误分析和解决方法(网络连接无法释放)
date:       2018-02-12
times:      23::09::56
author:     chensong
header-img: img/2018-02-12/bg_tcp.jpg
catalog: 	 true
tags:
    - 网络编程
    - TCP协议详解
---

## 前言

网络通信一直都是所有的框架的基础

## 正文

### 一， 基础复习

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/transfer.jpg?raw=true)

#### 1，IP分析

韩老师的视频学习，在这里感谢韩老师的视频

位置的分析

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/ip.jpg?raw=true)

##### ①，分析

1. version 版本号 (4位, 其他的IPV4 协议的扩展版本[如SIP协议和PIP协议])
2. 首部长度: 标识该ip头部有多少个32bit字(4字节)。因为4位最大表示15, 所以IP头部最长是60字节。
3. 区分服务(TOS):  8位服务类型包括一个3位的优先权字段(现在已经被忽略)，4位的TOS字段和1位保留字段(必须置0)。4位的TOS字段分别表示:最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需求要来设置它。比如ssh和Telnet这样的登录程序需要的是最小延时的服务， 而文件传输程序ftp则需要最大吞吐量的服务。
4. 16位总长度(total length): 是指整个IP数据报的长度， 以字节为单位，因此ip数据报的最大长度为65535($2^{16}$ - 1)字节。但由于 MTU 的限制， 长度超过MTU的数据报都将被分片传输, 所以实际传输的ip数据报(或分片) 的长度都远远没有达到最大值。接下来的3个字节则描述了如何实现分片。
5. 16位标识: 唯一地标识主机发送的每一个数据报。其初始值由系统随机生成: 每发送一个数据报， 其值就加1. 该值在数据报分片时被复制到每个分片中， 因此同一个数据报的所有分片都具有相同的标识值。
6. 3位标志: 3位标志字段的第一位保留。第二位(Don't Fragment DF) 表示"禁止分片"。如果设置了这个位， IP模块将不对数据报进行分片。 在这种情况下， 如果IP数据报长度超过MTU的话， IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位(More Fragment, MF)表示 "更多分片"。 除了数据报的最后一个分片外， 其他分片都要把它置1。
7. 片偏移: 13位分片偏移(fragmentation offset) 是分片相对原始IP数据报开始处(仅指数据部分)的偏移。 实际的偏移值是该值左移3位(乘8)后得到的。 由于这个原因，除了最后一个IP分片外， 每个IP的数据部分的长度必须是8的整数倍(这样才能保证后面的IP分片拥有一个合适的偏移值)
8. 生存时间: 8位生存时间(Time To Live, TTL)是数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(常见的值是64)。数据报在转发过程中每经过一个路由，该值就被路由器减1。 当TTL值被为0时， 路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以防止数据报陷入路由循环。
9. 协议: 8位协议(protocol) 用来区分上层协议， 在文件/etc/protocols 中定义了所有上层协议对应的protocol字段的数值。其中， ICMP是1， TCP是 6， UDP是17， 
10. 首部校验和: 16位头部校验和(header checksum) 由发送端填充，接受端对其使用CRC算法以检验IP数据报头部(注意， 仅检验头部)在传输过程中是否损坏。
11. 32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接受端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。
12. 可选择字段: IPv4最后一个选项字段(option)是可变长的可选信息。 这部分最多包含40字节，因为IP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。

> 可用的IP选项包含:

1. 记录路由(record route), 告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分， 这样我们就可用跟踪数据报的传递路径。
2. 时间戳(timestamp), 告诉每个路由器都将数据报被转发的时间(或者时间与IP地址对)填入IP头部的选项部分，这样就可以测量途径路由之间数据报传输的时间。
3. 松散源路由选择(loose source routing),指定一个路由器IP地址列表，数据报发送过过程必须经过其中所有的路由器。
4. 严格源路由选择(strict source routing), 和松散源路由选择类似，不过数据报只能经过被指定的路由器。

抓包分析 开启二进制查看 [-x]

> sudo tcpdump -ntx -i lo

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/lo_tcpdump.png?raw=true)

IPv4头部各个字段详解

|十六进制数|十进制数表示|IP头部信息|
|:--:|:--:|:--|
|0x4|4|IP版本号|
|0x5|5|头部长度为5个32位(20字节)|
|0x10||TOS选项中最小延时服务被开启|
|0x003c|60|数据报总长度，60字节|
|0x17a9||数据报标识(动态的)|
|0x4||设置了禁止分片标志|
|0x000|0|分片偏移|
|0x40|64|TTL被设为64|
|0x06|6|协议字段为6，表示上层协议是TCP协议|
|0x2501||IP头部校验和|
|0x7f000001||32位源端IP地址127.0.0.1|
|0x7f000001||32位目的端IP地址127.0.0.1|
||||

telnet服务选择使用具有最小延时的服务


![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/ipv4.jpg?raw=true)


##### ②，包的偏移量

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/ipv4_offset.jpg?raw=true)

包工具分析

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/tcpdump.jpg?raw=true)

#### 2，arp欺骗技术的分析

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/arp_cheating_technology.jpg?raw=true)


#### 3, 协议

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/ip/agreement.jpg?raw=true)

### 二， TCP状态转换图

#### 1， TCP状态转换图

```
虚线：表示服务器的正常状态转换
实线：表示客户端的正常状态转换
应用：表示状态转换在应用进程发起操作时发生
接收：表示状态转换在接收到分节发生
发送：表示这个转换发生什么
```

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/TCP_state_transition_diagram.png?raw=true)

#### 2， TCP连接的分组交换


![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/Packet_switching_over_TCP_connections.png?raw=true)

#### 3，CLOSE_WAIT状态出现时机

有一端主动关闭socket链接, 在没有关闭socket链接的一端出现CLOSE_WAIT状态, 主动关闭socket的一端出现了FIN_WAIT_2状态, 在主动关闭socket一端没有收到被动关闭一端的响应会等待73秒后关闭, 而被动关闭有会有大量CLOSE_WAIT状态 的原因是没有关闭socket连接(网络连接无法释放)

##### ①， 服务端有大量CLOSE_WAIT状态, 和客户端FIN_WAIT_2状态的使用

命令

```
tcpdump tcp port 80
```

抓包分析


![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/tcpdump.png?raw=true)

######  ②， 抓包分析结果

客户发送了FIN 服务端回一个ACK就介绍了

这是服务端的测试的代码测试的代码  

```
#include	"unp.h"
#include	<time.h>

int main(int argc, char **argv)
{
	int					listenfd, connfd;
	socklen_t			len;
	struct sockaddr_in	servaddr, cliaddr;
	char				buff[MAXLINE];
	time_t				ticks;
	int 				optval = 1;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);	/* daytime server */

	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

	Listen(listenfd, LISTENQ);
	//端口复用
	//端口复用
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

	for ( ; ; ) 
	{
		len = sizeof(cliaddr);
		connfd = Accept(listenfd, (SA *) &cliaddr, &len);
		printf("connection from %s, port %d\n",
			   Inet_ntop(AF_INET, &cliaddr.sin_addr, buff, sizeof(buff)),
			   ntohs(cliaddr.sin_port));

		ticks = time(NULL);
		snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
		//休息 了                就没有关闭服务端出现大量的CLOSE_WAIT状态
		sleep(1000);
		Write(connfd, buff, strlen(buff));

		Close(connfd);
	}
}
```

客户端的代码

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <strings.h>
#include <unistd.h>
#include <arpa/inet.h>

#define SERV_PORT 8888
#define SERV_IP "47.93.31.88"
#define MAXLINE 1024


int main(int argc, char **argv)
{
	int					sockfd, n;
	char				recvline[MAXLINE + 1];
	struct sockaddr_in	servaddr;


	if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
		printf("socket error\n");

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port   = htons(SERV_PORT);	/* daytime server */
	if (inet_pton(AF_INET, SERV_IP, &servaddr.sin_addr) <= 0)
		printf("inet_pton error for %s\n", SERV_IP);

	if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		printf("connect error\n");

	
	close(sockfd);

#if 0
	while ( (n = read(sockfd, recvline, MAXLINE)) > 0) {
		recvline[n] = 0;	/* null terminate */
		if (fputs(recvline, stdout) == EOF)
			printf("fputs error\n");
	}
	if (n < 0)
		printf("read error\n");
#endif 
	exit(0);
}
```


服务端的CLOSE_WAIT的状态

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/server_CLOSE_WAIT_status.png?raw=true)

客户端FIN_WAIT_2状态

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/client_FIN_WAIT_2_status.png?raw=true)


#### 4, 解决上面的问题是 出现大量CLOSE_WAIT状态 

原因是被动关闭的一端没有关闭socket连接 导致大量CLOSE_WAIT状态

现在就是关闭服务端socket连接

服务端的代码:

```
#include	"unp.h"
#include	<time.h>

int main(int argc, char **argv)
{
	int					listenfd, connfd;
	socklen_t			len;
	struct sockaddr_in	servaddr, cliaddr;
	char				buff[MAXLINE];
	time_t				ticks;
	int 				optval = 1;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);	/* daytime server */

	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

	Listen(listenfd, LISTENQ);
	//端口复用
	//端口复用
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));
	//地址复用
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

	for ( ; ; ) 
	{
		len = sizeof(cliaddr);
		connfd = Accept(listenfd, (SA *) &cliaddr, &len);
		printf("connection from %s, port %d\n",
			   Inet_ntop(AF_INET, &cliaddr.sin_addr, buff, sizeof(buff)),
			   ntohs(cliaddr.sin_port));

		ticks = time(NULL);
		snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
		//sleep(1000);
		Write(connfd, buff, strlen(buff));

		Close(connfd);
	}
}
```
	
效果图:

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2018-02-12/sucuss.png?raw=true)

## 结语
