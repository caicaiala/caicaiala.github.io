---
layout:     post
title:      socket选项
subtitle:   boost库的socket选项设置
date:       2019-02-02
times:      00::57::46
author:     chensong
header-img: img/2019-02-02/bg_socketopt.jpg
catalog: 	 true
tags:
    - 网络编程
---


## 前言

socket选项


## 正文


### 一, sockopt参数


设置socket的参数的函数

```
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int getsockopt(int sockfd, int level, int optname,
              void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname,
              const void *optval, socklen_t optlen);

```

#### 1，sockopt的选项

[^_^]:
	sockopt的选项的表格begin


<table border=0 cellpadding=0 cellspacing=0 width=1237 style='border-collapse:
 collapse;table-layout:fixed;width:928pt'>
 <col width=149 style='mso-width-source:userset;mso-width-alt:4768;width:112pt'>
 <col width=193 style='mso-width-source:userset;mso-width-alt:6176;width:145pt'>
 <col width=131 style='mso-width-source:userset;mso-width-alt:4192;width:98pt'>
 <col width=764 style='mso-width-source:userset;mso-width-alt:24448;width:573pt'>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 width=149 style='height:14.25pt;width:112pt'>level</td>
  <td class=xl1529103 width=193 style='width:145pt'>option name</td>
  <td class=xl1529103 width=131 style='width:98pt'>数据类型</td>
  <td class=xl1529103 width=764 style='width:573pt'>说明</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=14 height=266 class=xl6629103 style='height:199.5pt'>SOL_SOCKET(通用socket选项,
  与协议无关)</td>
  <td class=xl1529103>SO_DEBUG</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>打开调试信息</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'>SO_REUSEADDR</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>重用本地地址</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'>SO_TYPE</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>获取socket类型</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'>SO_ERROR</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>获取并清除socket错误状态</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'>SO_DONTROUTE</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>不查看路由表，直接将数据发送给本地局域网内的主机。含义和send系统调用的MSG_DONTROUTE标志类似</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'>SO_RCVBUF</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>TCP接受缓冲区大小</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'>SO_SNDBUF</td>
  <td class=xl1529103>int</td>
  <td class=xl1529103>TCP发送缓冲区大小</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_KEEPALIVE</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>发送周期性保活报文以维持连接</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_OOBINLINE</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>接收到的带外数据将保留在普通数据的输入队列中(在线保留)</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_LINGER</td>
  <td class=xl6629103>linger</td>
  <td class=xl1529103>若有数据待发送, 则延迟关闭</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_RCVLOWAT</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>TCP接收缓冲区低水位标记</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_SNDLOWAT</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>TCP发送缓冲区低水位标记</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_RCVTIMEO</td>
  <td class=xl6629103>itmeval</td>
  <td class=xl1529103>recv,recvmsg,accept [返回-1， 设置errno为EAGAIN或EWOULDBLOCK]</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>SO_SNDTIMEO</td>
  <td class=xl6629103>timeval</td>
  <td class=xl1529103>send, sendmsg [返回-1， 设置errno为EAGAIN或EWOULDBLOCK], connect
  [[返回-1， 设置errno为EWOULDBLOCK]]</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=2 height=38 class=xl6629103 style='height:28.5pt'>IPPROTO_IPv4(IPV4选项)</td>
  <td class=xl6529103>IP_TOS</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>服务类型</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>IP_TTL</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>保活时间</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=4 height=76 class=xl6629103 style='height:57.0pt'>IPPROTO_IPv6(IPv6选项)</td>
  <td class=xl6529103>IPV6_NEXTHOP</td>
  <td class=xl6629103>sockaddr_in6</td>
  <td class=xl1529103>下一跳IP地址</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>IPV6_RECVPKTINFO</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>接收分组信息</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>IPV6_DONTFRAG</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>禁止分片</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>IPV6_RECVTCLASS</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>接收通讯类型</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=3 height=57 class=xl6629103 style='height:42.75pt'>IPPROTO_TCP(TCP选项)</td>
  <td class=xl6529103>TCP_MAXSNG</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>TCP最大报文段大小</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl6529103 style='height:14.25pt'>TCP_NODELAY</td>
  <td class=xl6629103>int</td>
  <td class=xl1529103>禁止Nagle算法</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl1529103 style='height:14.25pt'></td>
  <td class=xl1529103></td>
  <td class=xl1529103></td>
 </tr>
</table>

[^_^]:
    sockopt的选项的表格 结束 Connection refused
    errno错误码 vim /usr/include/asm-generic/errno.h 

getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并且设置errno

对于服务器而言， 有部分socket选项只能在调用listen系统调用前针对监听socket设置的才有效。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤(因为listen监听队列中的连接至少已进入SYN_RCVD状态)，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。对这种情况， 

linux给开放人员提供的解决方案是:

对于监听socket设置这些socket选项， 那么accept返回的连接socket将自动继承这些选项。 这些socket选项包含：

1. SO_DEBUG
2. SO_DONTROUTE
3. SO_KEEPALIVE
4. SO_LINGER
5. SO_OOBINLINE
6. SO_RCVBUF
7. SO_RCVLOWAT
8. SO_SNDBUF
9. SO_SNDLOWAT
10. TCP_MAXSEG
11. TCP_NODELAY

client 而言 这些socket选项应该在connect函数之前设置， 因为connect调用成功返回之后， TCP三次握手已经完成了



### 二, SO_SNDBUF 和 SO_RECVBUF 选项

SO_SNDBUF 和 SO_RECVBUF 选项分别表示TCP发送缓冲区和接受缓冲区的大小。 不过

发送缓冲区和接受缓冲区的修改配置文件

/proc/sys/net/ipv4/tcp_wmem
/proc/sys/net/ipv4/tcp_rmem

三个参数分别指定是缓冲区

1.  最小值
2.  默认值
3.  最大值


测试程序

client

```
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <unistd.h>
#include <cstring>


#define   BUFFER_SIZE   512

int main(int argc, char *argv[])
{
  if (argc <= 2)
  {
    printf("usage: %s ip_address port_number send_bufer_seize\n", basename(argv[0]));
    return 1;
  }
  const char * ip = argv[1];
  
  int port = atoi(argv[2]);
  
  struct sockaddr_in server_address;
  bzero(&server_address, sizeof(server_address));
  server_address.sin_family = AF_INET;
  inet_pton(AF_INET, ip, &server_address.sin_addr);
  server_address.sin_port = htons(port);
  // create socket
  int sock = socket(PF_INET, SOCK_STREAM, 0);
  if(sock <= 0)
  {
    close(sock);
    printf("create socket error = %d\n", errno);
    return 0;
  }
  
  int sendbuf = atoi(argv[3]);
  int len = sizeof(sendbuf);
  
  // setting TCP SEDBUFF size read 
  setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &sendbuf, sizeof(sendbuf));
  getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &sendbuf, (socklen_t *)&len);
  printf("the tcp send buffer size after setting is %d\n", sendbuf);
  
  if (connect(sock, (struct sockaddr *)&server_address, sizeof(server_address)) != -1)
  {
    char buffer[BUFFER_SIZE];
    memset(buffer, 'a', BUFFER_SIZE);
    send(sock, buffer, BUFFER_SIZE, 0);
    
  }
  close(sock);
  return 0;
}
```

server

```
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <unistd.h>
#include <cstring>
#include <cerrno>


#define BUFFER_SIZE   1024


int main(int argc, char *argv[])
{
  if (argc <= 2)
  {
    printf("usage: %s ip_address port_number recv_buffer_seize\n", basename(argv[0]));
    return 1;
  }
  int ret = 0;
  const char * ip = argv[1];
  int port = atoi(argv[2]);
  
  struct sockaddr_in address;
  bzero(&address, sizeof(address));
  address.sin_family = AF_INET;
  inet_pton(AF_INET, ip, &address.sin_addr);
  address.sin_port = htons(port);
  
  
  // create socket
  int sock = socket(PF_INET, SOCK_STREAM, 0);
  if(sock <= 0)
  {
    close(sock);
    printf("create socket error = %d\n", errno);
    return 0;
  }
  
  int recvbuf = atoi(argv[3]);
  int len = sizeof(recvbuf);
  
  // setting TCP SEDBUFF size read 
  setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &recvbuf, sizeof(recvbuf));
  getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &recvbuf, (socklen_t *)&len);
  printf("the tcp recv buffer size after setting is %d\n", recvbuf);
  
  ret = bind(sock, (struct sockaddr *)&address, sizeof(address));
  if (ret == -1)
  {
    close(sock);
    printf("bind socket error = %d\n", errno);
    return 1;
  }
  
  ret = listen(sock, 5);
  if (ret == -1)
  {
    close(sock);
    printf("listen socket error = %d\n", errno);
    return 1;
  }
  
  struct sockaddr_in client;
  socklen_t client_addrlength = sizeof(client);
  int connfd = accept(sock, (struct sockaddr*) &client, &client_addrlength);
  if (connfd < 0)
  {
    printf("errno is : %d\n", errno);
  }
  else
  {
    char buffer[BUFFER_SIZE];
    memset(buffer, '\0', BUFFER_SIZE);
    while(recv(connfd, buffer, BUFFER_SIZE - 1, 0) > 0) {}
    close(connfd);
  }
  
  close(sock);
  return 0;
}
```


开放端口
>/sbin/iptables -I INPUT -p tcp --dport 9992 -j ACCEPT

tcpdump 抓包

>tcpdump  -nt -i ens33 port 9992

效果图片

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2019-02-02/tcpdump_sendbuff.png?raw=true)


## 结语