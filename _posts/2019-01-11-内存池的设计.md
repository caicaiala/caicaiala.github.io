---
layout:     post
title:      内存池的设计
subtitle:   内存池的设计原理分析
date:       2019-01-11
times:      17::02::45
author:     chensong
header-img: img/2019-01-11/bg_mem_pool.jpg
catalog: 	 true
tags:
    - 游戏服务器
---

## 前言

默认内存管理函数的不足

利用默认的内存管理操作符new/delete和函数malloc()/free()在堆上分配和释放内存会有一些额外的开销。

系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。

可见，如果应用程序频繁地在堆上分配和释放内存，会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。


## 正文


### 一, 内存池的设计思想

1. 先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象；
2. 每个对象连同一个指向下一个对象的指针一起构成一个内存节点（node）。各个空闲的内存节点通过指针形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间；
3. 某个内存节点一旦分配出去，从空闲内存节点链表中去除；
4. 一旦释放了某个内存节点的空间，又将该节点重新加入空闲内存节点链表；
5. 如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2019-01-11/mempool.png?raw=true)


内存池的数据结构

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2019-01-11/mem_pool_struct.png?raw=true)

### 二, 我们要注意的问题

1. 需要内存大于内存池中内存单元的处理
2. 内存单元的利用率(内存单元使用频率相同)





## 结语

